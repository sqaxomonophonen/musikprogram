

Keyboard stuff is hard! Why is it so hard!


For text input we trust the OS to have a facility that tells us what text has
been typed. On X11 I'm using:

  Xutf8LookupString()

This mostly works fine. Except I'm not sure what to think about
Xutf8LookupString() outputting codepoint='\b' for [ctrl]+[h]. It's what a
terminal emulator wants, yes, but that's about it? (So, X11 is a software
solution for making terminal emulators, got it). Firefox (on Linux) definitely
doesn't use [ctrl]+key for control-code input; many [ctrl]+keys are shortcuts
([ctrl]+[h] is "open history", not "backspace"), and those that appear unmapped
(e.g. [ctrl]+[3] which should be equivalent to [esc]) do not seem to have any
control-code like effect. However, it COULD also be argued that it's similar to
[altgr]+[5] giving "µ" (on my end), which is a "feature that I agree on", so
who am I to argue against someone who prefers [ctrl]+[h] over [backspace]? :-)

Unfortunately, it seems that X11 has no direct way of disabling/changing this
behavior on the application level (you _might_ be able to change it globally,
but you probably don't want to do that). However:
 - it seems that control-code codepoints only come from "ASCII keys", and only
   a subset of them, so [ctrl]+[æ] gives "æ", and [ctrl]+[shift]+"æ" gives "Æ"
 - the "bad codepoints" are 0 to 31, and 127 (DEL)
 - if you get a "bad codepoint", then the KeySym returned by
   Xutf8LookupString() is a good "codepoint compatible" replacement, that also
   respects upper/lowercase stuff
 - NOTE: the KeySym returned by XLookupKeysym() does NOT seem like a good
   replacement; e.g. it will be "a" whether you press [a] or [shift]+[a]

Another design consideration is that, it seems as if it's at least
theoretically possible to have a single key event output more than one
codepoint... but I don't really know of any practical examples of this?
However, I'm 99% sure (really I'm not) that this only relates to text input, so
I could *probably* get away with emitting a `struct gpudl_event_key` per
codepoint, instead of actually supporting arbitrary-length codepoint sequences
in one event. Probably.


Anyway, the above is "The Easy Stuff".


Handling keyboard shortcuts seems... uh... worse? I need to store keyboard
shortcuts in config files, and also display them inside mprg via a shortcut
editor. I'm pretty sure I want [shift]+[1] and [altgr]+[5] to be stored and
displayed as such, and not as "!" and "µ" respectively. This is because
shortcuts are never used for text input, but for actions, so you never see "!"
on the screen when activating the [shift]+[1] shortcut (you're probably also
mentally thinking about it as [shift]+[1], rather than "!", when activating a
shortcut... but as "!" when typing text). Furthermore, it often makes sense to
have stuff like [shift]+[0-9] activate 10 different related "things" (layouts,
tabs, presets,...), and so, defining a shortcut as [shift]+[1] should work on
ANY keyboard layout (even non-latin keyboards have number keys), whereas the
codepoint outputs are not "portable" between layouts (you'd get `!@#$%^&*()` on
US layout, and `!"#¤%&/()=` on DK layout). There are some odd exceptions to
this "in the wild". For instance, browsers, seemingly inspired by vim (itself
inspired by other stuff?), have begun opening a search field when typing "/",
and this seems to be codepoint based, so you'd press physically different keys
on different layouts ([/] on US-layout, [shift]+[7] on DK-layout). But assuming
codepoint input stuff works, I can always support stuff like this (however,
mprg is going to be very text-input'ey, albeit mostly ASCII, so I probably
don't want this?).

So, codepoint input is rather useless for shortcuts.

We also have keycodes (this is X11 terminology; called "keycode" in the
XKeyEvent type; othertimes referred to as "scancodes"). These correspond to the
"physical key location". E.g. you can assume [esc] to have the same keycode
across all (?) keyboards. However, this is a bad assumption to work with,
because people sometimes remap their keyboards; e.g. on Linux, people often
remap [capslock]; this doesn't change the keycode (afaik), but it changes
everything else. Also, many keys look different on the keyboard, e.g. [;] on
US-layout has the same physical location (and keycode) as [æ] on DK-layout, but
different keysym/codepoint:

KeyPress event, serial 32, synthetic NO, window 0x3e00001,
    root 0x13e, subw 0x0, time 1710686587, (555,910), root:(556,911),
    state 0x0, keycode 47 (keysym 0x3b, semicolon), same_screen YES,
    XLookupString gives 1 bytes: (3b) ";"
    XmbLookupString gives 1 bytes: (3b) ";"
    XFilterEvent returns: False

KeyPress event, serial 32, synthetic NO, window 0x3e00001,
    root 0x13e, subw 0x0, time 1710718692, (555,910), root:(556,911),
    state 0x0, keycode 47 (keysym 0xe6, ae), same_screen YES,
    XLookupString gives 2 bytes: (c3 a6) "æ"
    XmbLookupString gives 2 bytes: (c3 a6) "æ"
    XFilterEvent returns: False

(/usr/bin/xev output)

So keycodes are ALSO rather useless for shortcuts. They MAY, however, prove
useful if I need to know when a key is released (things like scrolling with
arrow keys, tracker keyjazz stuff, etc). These reason is that key release
events are typically not as ... "eventful" ... as key presses; the text output
from a key press can be affected by... modifier keys, dead keys ([¨],[a]=>"ä"
on DK-layout), compose key. Maybe ligatures is even a thing ([i],[j] => "ĳ"?),
but releases typically don't have a really meaningful text representation, and
rather relates to a physical key being released (in fact, Xutf8LookupString()
and friends claim to have "undefined behavior" on KeyRelease events). So, to
properly detect key releases, it might be possible to do something like this:
 - Wait for a key press where you are interested in knowing when it's released.
   You can probably detect this using a "higher-level approach", based on
   keysym or codepoint?
 - Remember the keycode for this event...
 - Wait until a KeyRelease event with the same keycode is seen; the key is now
   released


In between keycodes and codepoints we have "keysyms" (X11 terminology). These
_ought_ to correspond to the physical pictogram seen on the key on your
keyboard. But sometimes people use a keyboard layout that doesn't match their
physical keyboard (for many years I used US-layout on a DK-keyboard), so it
might be more accurate to say that "the ideal keysym" is a single
keycode/scancode mapped to a keysym, via whatever keyboard layout you're
currently using. Another important "keysym feature" is that we have keysyms for
keys that have no text representation, e.g. [shift], [home] and the arrow keys.
And, if we assume that control-code text input is bad, then also keys like
[esc], [backspace] and [enter].

On X11, XLookupKeysym() seems to be a better choice than Xutf8LookupString() to
get to the "ideal keysym":

 - for [a], both XLookupKeysym() and Xutf8LookupString() gives keysym='a'

 - for [shift]+[a], XLookupKeysym() gives keysym='a' whereas
   Xutf8LookupString() gives keysym='A'

Another problem with X11 keysyms is that they're all non-standard;
/usr/include/X11/keysymdef.h contains 2000+ keysyms for many different keyboard
layouts, but they don't correspond to codepoints. Other operating systems
(Windows/Mac) seem to at least have some kind of unicode representation for
non-ascii keys representing printable characters. `imKStoUCS.c` contains
x11-keysym-to-codepoint mapping code, so it might be worth stealing?


So... in conclusion:

 - I need special keysyms for special/common keys: e.g. [esc], [home], [f1]
   thru [f12] and beyond, arrow keys, modifier keys...

 - Printable character keys should always be represented by a unicode codepoint

 - Unicode codepoints are 21 bits, and there are also so-called Private Use
   Areas (PUA), the first area from U+E000 to U+F8FF. So "special keysyms"
   could either live above 1<<21, or in a PUA?

 - I should probably prefer lowercase codepoints, so [a] would be 'a', not 'A'.
   I hope this is consistent across platforms :-) I also suppose it's
   technically possible to map a key to "A" (instead of "a"), in which case "A"
   is correct?

 - Each keysym must have a unique unicode _string_ (not codepoint)
   representation, e.g. "SHIFT" for [shift], and "æ" for [æ]. This is required
   for loading/saving config files, and also visual display of a keysym (e.g.
   for a shortcut editor)


In order to map X11 keysyms to codepoints, I can probably reuse `imKStoUCS.c`.
But another approach is parsing keysymdef.h:

  #define XK_ae                            0x00e6  /* U+00E6 LATIN SMALL LETTER AE */
  #define XK_Cyrillic_GHE_bar           0x1000492  /* U+0492 CYRILLIC CAPITAL LETTER GHE WITH STROKE */
  #define XK_kana_A                        0x04b1  /* U+30A2 KATAKANA LETTER A */

That is, I have:
 - the keysym name (XK_ae, XK_Cyrillic_GHE_bar, XK_kana_A)
 - the keysym value (0x00e6, 0x1000492, 0x04b1)
 - the unicode codepoint (U+00E6, U+0492, U+30A2)
Not all #defines have codepoints, but those that do should be easily parsable.


So what should the final-final-v3 `struct gpudl_event_key` look like?

struct gpudl_event_key {
	int pressed;   // 1 if pressed, 0 if released
	int modmask;   // modifier key bitmask
	int keysym;    // we've talked about this
	int codepoint; // unicode codepoint for text input, or 0 if not applicable
};

Should I have scancode too, or is keysym enough? Seeing that XLookupKeysym()
seems to have no "undefined behavior" for key releases (unlike
Xutf8LookupString()), I THINK I should be able to get by without a scancode
field?

Maybe I should remove modmask, because the application can keep track of it by
itself? Ideally, keysym is never affected by modmask.




Other remarks:


 - see: https://kbdlayout.info/features/ligatures -- some keyboard layouts have
   keys that emit 2+ codepoints


 - I don't think the above has problems with dead keys? And compose key seems
   related? The following `xev` output is from DK-layout, [¨],[a] => "ä"

        KeyPress event, serial 32, synthetic NO, window 0x1000001,
            root 0x13e, subw 0x0, time 1717608110, (455,378), root:(456,379),
            state 0x0, keycode 35 (keysym 0xfe57, dead_diaeresis), same_screen YES,
            XLookupString gives 2 bytes: (c2 a8) "¨"
            XmbLookupString gives 0 bytes:
            XFilterEvent returns: True
        
        KeyRelease event, serial 32, synthetic NO, window 0x1000001,
            root 0x13e, subw 0x0, time 1717608183, (455,378), root:(456,379),
            state 0x0, keycode 35 (keysym 0xfe57, dead_diaeresis), same_screen YES,
            XLookupString gives 2 bytes: (c2 a8) "¨"
            XFilterEvent returns: False
        
        KeyPress event, serial 32, synthetic NO, window 0x1000001,
            root 0x13e, subw 0x0, time 1717609465, (455,378), root:(456,379),
            state 0x0, keycode 38 (keysym 0x61, a), same_screen YES,
            XLookupString gives 1 bytes: (61) "a"
            XmbLookupString gives 1 bytes: (61) "a"
            XFilterEvent returns: True
        
        KeyPress event, serial 32, synthetic NO, window 0x1000001,
            root 0x13e, subw 0x0, time 1717609465, (455,378), root:(456,379),
            state 0x0, keycode 0 (keysym 0xe4, adiaeresis), same_screen YES,
            XLookupString gives 0 bytes:
            XmbLookupString gives 2 bytes: (c3 a4) "ä"
            XFilterEvent returns: False
        
        KeyRelease event, serial 32, synthetic NO, window 0x1000001,
            root 0x13e, subw 0x0, time 1717609585, (455,378), root:(456,379),
            state 0x0, keycode 38 (keysym 0x61, a), same_screen YES,
            XLookupString gives 1 bytes: (61) "a"
            XFilterEvent returns: False


   And the following `xev` output is from US-layout with compose key;
[compose],[a],[e] => "æ":

        KeyPress event, serial 32, synthetic NO, window 0x1000001,
            root 0x13e, subw 0x0, time 1717692812, (455,378), root:(456,379),
            state 0x0, keycode 66 (keysym 0xff20, Multi_key), same_screen YES,
            XLookupString gives 0 bytes:
            XmbLookupString gives 0 bytes:
            XFilterEvent returns: True
        
        KeyRelease event, serial 32, synthetic NO, window 0x1000001,
            root 0x13e, subw 0x0, time 1717692886, (455,378), root:(456,379),
            state 0x0, keycode 66 (keysym 0xff20, Multi_key), same_screen YES,
            XLookupString gives 0 bytes:
            XFilterEvent returns: False
        
        KeyPress event, serial 32, synthetic NO, window 0x1000001,
            root 0x13e, subw 0x0, time 1717693191, (455,378), root:(456,379),
            state 0x0, keycode 38 (keysym 0x61, a), same_screen YES,
            XLookupString gives 1 bytes: (61) "a"
            XmbLookupString gives 1 bytes: (61) "a"
            XFilterEvent returns: True
        
        KeyRelease event, serial 32, synthetic NO, window 0x1000001,
            root 0x13e, subw 0x0, time 1717693288, (455,378), root:(456,379),
            state 0x0, keycode 38 (keysym 0x61, a), same_screen YES,
            XLookupString gives 1 bytes: (61) "a"
            XFilterEvent returns: False
        
        KeyPress event, serial 32, synthetic NO, window 0x1000001,
            root 0x13e, subw 0x0, time 1717693502, (455,378), root:(456,379),
            state 0x0, keycode 26 (keysym 0x65, e), same_screen YES,
            XLookupString gives 1 bytes: (65) "e"
            XmbLookupString gives 1 bytes: (65) "e"
            XFilterEvent returns: True
        
        KeyPress event, serial 32, synthetic NO, window 0x1000001,
            root 0x13e, subw 0x0, time 1717693502, (455,378), root:(456,379),
            state 0x0, keycode 0 (keysym 0xe6, ae), same_screen YES,
            XLookupString gives 0 bytes:
            XmbLookupString gives 2 bytes: (c3 a6) "æ"
            XFilterEvent returns: False
        
        KeyRelease event, serial 32, synthetic NO, window 0x1000001,
            root 0x13e, subw 0x0, time 1717693575, (455,378), root:(456,379),
            state 0x0, keycode 26 (keysym 0x65, e), same_screen YES,
            XLookupString gives 1 bytes: (65) "e"
            XFilterEvent returns: False

   Note that "XFilterEvent returns: True" for all KeyPress events that are not
   part of the actual character output...

   Also, while unconfirmed, I'm pretty sure all the keysyms would be "ideal"
   (according to above discussion) when using XLookupKeysym() (for key presses,
   xev uses XmbLookupString() which seems to work similar to
   Xutf8LookupString(); i.e. keysyms are weird)

   I.e. shortcuts should probably never use compose/dead keys, and the actual
   key press seems unaffected when using XLookupKeysym()

   See also: https://kbdlayout.info/features/deadkeys










Some references:

X11 keysym definitions:
  /usr/include/X11/keysymdef.h

X11 keysym documentation, some potentially useful background info:
  https://www.x.org/releases/X11R7.7/doc/xproto/x11protocol.html#keysym_encoding

X11 stuff, e.g. XKeyEvent struct:
  /usr/include/X11/Xlib.h

Database of keyboard layouts, some potentially useful XML downloads:
  http://kbdlayout.info/

X11 keysym => codepoint mapping?
  imKStoUCS.c
  https://github.com/google/filament/blob/main/third_party/libsdl2/src/video/x11/imKStoUCS.c

tcl/tk musings on this stuff:
  https://wiki.tcl-lang.org/page/KeySyms+on+platforms+other+than+X11

Windows Virtual Key Codes / VK_*:
  https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes



